## 通知用户版本更新刷新页面

在每次打包生产代码时，在 public 目录下生成一个 version.json 版本信息文件，页面跳转时请求服务器端的 version.json 中的版本号和浏览器本地缓存的版本号进行对比，从而监控版本迭代更新，实现页面自动更新，获取新的 index.html 文件（前提是服务器端对 index.html 和 version.json 不缓存）。

1. 首先应该禁止浏览器缓存 index.html 和 version.json
```nginx
location /index.html {
    add_header Cache-Control "no-cache, no-store, must-revalidate";
    add_header Pragma "no-cache";
    add_header Expires 0;
}
location /version.json {
    add_header Cache-Control "no-cache, no-store, must-revalidate";
    add_header Pragma "no-cache";
    add_header Expires 0;
}
```
2. 编写 Vite 插件实现打包时自动生成版本信息
新建文件 src/plugins/versionUpdatePlugin.ts
```ts
// src/plugins/versionUpdatePlugin.ts
import fs from "node:fs";
import path from "node:path";

import type { ResolvedConfig } from "vite";

function writeVersion(versionFile: string, content: string) {
  // 写入文件
  fs.writeFile(versionFile, content, (err) => {
    if (err) throw err;
  });
}

export default (version: string | number) => {
  let config: ResolvedConfig;
  return {
    name: "version-update",
    configResolved(resolvedConfig: ResolvedConfig) {
      // 存储最终解析的配置
      config = resolvedConfig;
    },
    buildStart() {
      // 生成版本信息文件路径
      const file = config.publicDir + path.sep + "version.json";
      // 这里使用编译时间作为版本信息
      const content = JSON.stringify({ version });
      if (fs.existsSync(config.publicDir)) {
        writeVersion(file, content);
      } else {
        fs.mkdir(config.publicDir, (err) => {
          if (err) throw err;
          writeVersion(file, content);
        });
      }
    },
  };
};
```
3. 在 vite.config.ts 中使用插件
对于使用 TypeScript 的开发者来说，请确保在 env.d.ts 或 vite-env.d.ts 文件中添加类型声明，以获得类型检查以及代码提示。
```ts
// vite-env.d.ts
declare const __APP_VERSION__: string
```
配置 vite.config.js
```ts
import versionUpdatePlugin from "./src/plugins/versionUpdatePlugin";

export default defineConfig(({ mode }) => {
    ...
    const now = new Date().getTime();
    return {
        ...
        define: {
        __APP_VERSION__: now,
        },
        plugins: [
        vue(),
        versionUpdatePlugin({
            version: now,
        }),
        ],
        ...
    };
});
```
4. 路由跳转时，实时检测版本
检测到新版本自动刷新页面，应该使用前置守卫，在跳转失败报错前检测，跳转失败不会触发后置守卫
```ts
// router/index.ts
import { Modal } from "ant-design-vue";
...
// 这里在路由全局前置守卫中检查版本
router.beforeEach(async () => {
  console.log("路由守卫");
  await versionCheck();
});

// 版本监控
const versionCheck = async () => {
  // if (import.meta.env.MODE === "development") return;
  // const response = await axios.get("version.json");
  const responseVersion = 1721114748501;
  // __APP_VERSION__  获取环境变量设置的值，判断是否与生成的版本信息一致
  console.log("__APP_VERSION__", __APP_VERSION__);
  if (__APP_VERSION__ !== responseVersion) {
    Modal.confirm({
      title: "版本更新提示",
      content: "检测到新版本，更新之后将能体验到更多好用的功能，是否现在更新？",
      onOk() {
        window.location.reload();
      },
      onCancel() {},
    });
  }
};
...
```

## 网站整体换肤
自定义主题 自己项目中使用的是 vue3 + vite + antdv + less，步骤如下：
antdv 的官网对于主题的切换是有说明的：[定制主题](https://3x.antdv.com/docs/vue/customize-theme-cn)

官网虽然没有提供 vite 方式修改主题的说明，但是举了vue cli ，webpack的例子，其实我们也能知道了，在 vite 中是差不多的，都是通过 less 中的modifyVars进行修改。试试
```js
css: {
  preprocessorOptions: {
    less: {
      modifyVars: {
        'primary-color': '#1DA57A',
        'link-color': '#1DA57A',
        'border-radius-base': '2px',
      },
      javascriptEnabled: true
    }
  }
}
```
想要实现动态切换主题，这里我使用一个vite插件：[vite-plugin-theme-preprocessor](https://github.com/GitOfZGT/vite-plugin-theme-preprocessor/blob/master/README.zh.md)
> 一个vite v2.0+插件，用于实现多个 less、sass 变量文件编译出多主题的 css，使得基于less、sass以及css modules的主题样式在线动态切换变得很简单。
根据仓库中的说明，我们需要先安装插件：
```bash
yarn add @zougt/vite-plugin-theme-preprocessor -D
yarn add path --save
```
> path是用来解析路径的，这在我们项目中很多地方都会用得到，同样。这里也需要。

然后我们需要在 vite.config.ts 中使用这个插件。
```ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'
import themePreprocessorPlugin from "@zougt/vite-plugin-theme-preprocessor";
...
export default defineConfig({
  plugins: [
    vue(),
    themePreprocessorPlugin({
      less: {
        // 各个主题文件的位置
        multipleScopeVars: [
          {
            scopeName: "theme-default",
            path: path.resolve("src/theme/default.less"), // 自定义主题样式文件路径 
          },
          {
            scopeName: "theme-dark",
            path: path.resolve("src/theme/dark.less"), // 自定义主题样式文件路径 
          },
        ],
      },
    }),
  ],
  // 开启less支持
  css: {
    preprocessorOptions: {
      less: {
        javascriptEnabled: true
      }
    }
  }
  ...
})
```
上面，我们定义了两个主题分别是：theme-default与 theme-dark 以及对应主题文件的位置。

我们切换主题就靠主题文件了。

接下来我们需要创建这两个主题文件，并分别引入ant的样式文件，注意是less格式。
```less
// src/theme/default.less
@import "ant-design-vue/lib/style/themes/default.less";
// 上面引入了 antdv 核心样式文件，我们可以对其进行修改，覆盖原来的达到我们的目的。
// 这里不仅能修改变量还能修改样式
// 比如我修改以下
// 全局主色 黄色
@primary-color: #ffa618; 
// 链接色 青色
@link-color: #18ffb2; 
```
```less
// src/theme/dark.less
@import "ant-design-vue/lib/style/themes/dark.less";
// 全局主色 绿色
@primary-color: #1cce42; 
// 链接色 粉红色
@link-color: #c76f98;
```
然后，我们就可以进行主题切换的逻辑了！
在需要改变动态切换主题的文件中绑定事件，并引入
```js
import { toggleTheme } from "@zougt/vite-plugin-theme-preprocessor/dist/browser-utils.js";
// 切换主题回调
const change = (value: boolean) => {
  // 如果开关打开，就切换为绿色主题，否则默认黄色主题
  if (value) {
    toggleTheme({
      scopeName: "theme-dark",
    });
    console.log("已切换为暗黑主题");
  } else {
    toggleTheme({
      scopeName: "theme-default",
    });
    console.log("已切换为默认主题");
  }
};
```

## node内存泄漏
内存泄漏是指程序在运行过程中，由于某些原因未能释放内存，导致内存占用不断增加，最终导致系统崩溃或崩溃后无法恢复。
### 常见的原因
* 1. 全局变量、闭包
    不当地使用全局变量或闭包可能导致对象无法被垃圾回收器回收。
* 2. 事件监听器
    添加的事件监听器，如果没有被正确移除，可能会导致内存泄露。
* 3. 计时器
    如 setInterval 创建的计时器如果一直没有被清除（clearInterval），将会持续占用内存。
* 4. DOM 元素
    如果 DOM 元素被创建后，没有正确地被移除，将会导致内存泄漏。
* 5. 大对象或集合
    如果创建了一个非常大的对象或集合，不断向大数组或对象中添加数据，并且没有及时释放，将会导致内存占用持续增长。
* 6. 第三方库
    使用第三方库时，如果库内部存在内存泄漏，也会导致整个应用出现内存泄漏。

### 解决方法
* 1. 使用闭包时，确保在不再需要时释放闭包中的变量。
* 2. 移除事件监听器，确保在不需要时移除事件监听器。
* 3. 清除计时器，确保在不需要时清除计时器。
* 4. 移除 DOM 元素，确保在不需要时移除 DOM 元素。
* 5. 及时释放大对象或集合，确保在不需要时释放大对象或集合。

## 低代码的理解
低代码是
一种开发模式，它允许开发者通过图形界面和少量的代码来构建应用程序，而无需深入了解编程语言和框架。这种模式的目标是提高开发效率，降低开发成本，并使非技术用户也能参与到应用程序的开发中。

低代码平台通常提供了一套可视化工具，如拖拽式界面设计器、表单生成器等，用户可以通过这些工具来创建应用程序的界面和逻辑。同时，低代码平台还提供了一些预定义的组件和模块，用户可以通过拖拽和配置来使用它们，从而快速构建出功能丰富的应用程序。
目前国内市面上比较流行的低代码平台有：
<!-- TODO: -->

### 低代码的产生背景
随着互联网技术的飞速发展，开发的技术栈趋于成熟后，企业对软件系统的需求日益增长，而传统的软件开发模式已经无法满足快速迭代和低成本的需求。因此，低代码平台应运而生，它通过简化开发流程，降低开发难度，提高开发效率，从而满足企业对软件系统的需求。

### 低代码的原理
可以通过配置化的低成本交互方式（主流是拖拽）加上少量的一些胶水代码，去满足一类应用的需求。这里笔者以发展更加成熟的B端低代码讲述，C端也是很类似，但是因为样式、动画等定制要求要比B端的复杂许多，所以目前前端低代码相对成熟的应用是在B端。低代码实现原理其实非常简单，就是先预置丰富的原子组件，通过拖拽选择所需组件在画板上进行位置的编排。之后，进行一些组件属性的设置。最终生产出一份jsonSchema或者供开发者二次开发的“源代码”，驱动用户端的内容渲染。

### 低代码的优缺点
#### 优点
1. 提高开发效率：低代码平台可以减少开发人员编写代码的时间，从而加快开发速度。
2. 降低开发成本：低代码平台通常提供了一些预定义的组件和模块，用户可以通过拖拽和配置来使用它们，从而降低开发成本。
3. 提高开发灵活性：低代码平台允许用户根据自己的需求进行定制，从而提高开发灵活性。
4. 适合非技术用户：低代码平台提供了一套可视化工具，如拖拽式界面设计器、表单生成器等，非技术用户也可以参与到应用程序的开发中。
5. 支持跨平台：低代码平台通常支持多种开发语言和框架，用户可以根据自己的需求选择合适的开发语言和框架。
#### 缺点
1. 限制灵活性：低代码平台通常提供了一些预定义的组件和模块，用户只能使用这些组件和模块，从而限制了开发灵活性。
2. 依赖平台：低代码平台通常依赖于特定的平台，用户需要购买或订阅平台服务，从而增加了成本。
3. 学习曲线：低代码平台提供了一套可视化工具，用户需要学习如何使用这些工具，从而增加了学习成本。
4. 代码质量：低代码平台生成的代码通常不如手工编写的代码质量高，因为低代码平台无法完全理解用户的需求和意图。
### 低代码适用场景
* 海报(不需要逻辑和交互)
* H5 运营活动页、问卷调查类页面(一次性页面，不需要后期维护)
* 汇报的演示大屏(fast)
* 中后台页面(需要逻辑和交互，但不需要复杂的业务逻辑)

### 低代码的挑战
* 代码质量：低代码平台生成的代码通常不如手工编写的代码质量高，因为低代码平台无法完全理解用户的需求和意图。
* 依赖平台：低代码平台通常依赖于特定的平台，用户需要购买或订阅平台服务，从而增加了成本。
* 学习曲线：低代码平台提供了一套可视化工具，用户需要学习如何使用这些工具，从而增加了学习成本。

### 低代码的未来发展趋势
低代码一定是有发展前景的，目前在一些特定的企业oa、sass或者标准化的业务场景比如审批流等特定场景下已经取得了不错的应用。

目前最理想的状态是整个产研团队一块推动的方式。这样产品、前端、后端、测试整个流程都对低代码平台有一个统一的功能预期，产品不提非标需求，前后端不写非标代码，测试不测非标功能，这样才能更好的发挥低代码的价值。

## npm run dev 的过程
npm run dev 命令是 Node.js 开发者常用的一个命令，它用来启动一个开发服务器或执行一系列预设的开发任务。这个命令的过程可以分解为以下几步：

### 1. 查找并执行脚本
npm首先会在项目的package.json文件中查找scripts字段下的dev属性，‌并找到与之对应的脚本命令。‌这意味着，‌执行npm run dev命令时，‌需要确保处于包含package.json文件的正确目录中。‌例如，‌如果package.json文件中配置了"dev": "node server.js"，‌那么执行npm run dev将会在当前目录下启动一个Node.js服务器，‌并执行server.js文件。‌

### 2. 检查依赖
在执行脚本之前，‌npm会检查项目中是否已安装了所有必要的依赖项。‌如果依赖项不存在，‌npm会尝试自动安装package.json中列出的依赖项。‌

### 3. 执行命令
一旦依赖项安装完成或确认已存在，‌npm将执行dev属性中指定的脚本命令。‌这可以是一个脚本、‌一个可执行文件或一个自定义的命令。‌例如，‌如果配置为"dev": "webpack serve --config webpack.dev.config.js"，‌那么执行npm run dev实际上是运行了webpack serve命令，‌并使用webpack.dev.config.js作为配置文件。‌

### 4. 启动开发服务器
‌webpack-dev-server（‌或类似工具如Vite等）‌会被启动，‌开始监听指定目录下的源代码变化，‌并且根据配置文件进行实时编译打包。‌

### 5. 模块加载与热更新
开发服务器不仅提供静态资源服务，‌还可能启用热模块替换功能（‌HMR）‌，‌使得在开发过程中修改代码后无需手动刷新浏览器就能看到变更效果。‌

### 6. 环境变量配置
如果在执行脚本的过程中使用了环境变量，‌比如通过-mode=development或读取.env.development文件来设置特定的开发环境变量，‌那么这个过程也会处理这些环境相关的配置。‌

### 7. 错误处理与日志输出
在执行过程中，‌如果遇到错误，‌npm会捕获并输出错误信息，‌帮助开发者定位和解决问题。‌同时，‌开发服务器可能会输出一些日志信息，‌如编译进度、‌警告和错误等，‌帮助开发者了解项目的运行状态。‌

总结：‌npm run dev 是一个常用的命令，‌它通过读取package.json文件中的配置，‌自动执行一系列预设的开发任务，‌如启动开发服务器、‌编译代码、‌热更新等，‌从而简化了开发流程。‌

## 时间复杂度和空间复杂度的理解
时间复杂度和空间复杂度是衡量算法效率的两个重要指标，它们分别反映了算法在执行时间和内存使用上的性能表现。
### 时间复杂度
时间复杂度和空间复杂度是衡量算法效率的两个重要指标，它关注的是随着输入规模增大，算法运行时间的增长趋势。时间复杂度用大O记号 ( O ) 来表示，常见的几种时间复杂度包括：

* 常数时间复杂度 ( O(1) )：无论输入规模如何，算法的运行时间都是固定的。
* 线性时间复杂度 ( O(n) )：算法的运行时间与输入规模成正比。
* 对数时间复杂度 ( O(\log n) )：算法的运行时间随着输入规模的增加而缓慢增长。
* 平方时间复杂度 ( O(n^2) )：算法的运行时间与输入规模的平方成正比，常见于双重循环中。
* 指数时间复杂度 ( O(2^n) )：算法的运行时间以指数形式增长，常见于递归算法中，如未优化的斐波那契数列计算。
在分析时间复杂度时，我们通常关注最坏情况下的时间复杂度，因为它给出了算法在任何情况下都不会超过的上限。

### 空间复杂度
空间复杂度表示的是算法运行过程中所需内存空间与输入数据规模之间的关系。它关注的是算法在执行过程中临时占用存储空间的变化趋势。空间复杂度同样使用大O记号来表示，常见的几种空间复杂度包括：

* 常数空间复杂度 ( O(1) )：算法所需的额外空间不随输入规模变化。
* 线性空间复杂度 ( O(n) )：算法所需的额外空间与输入规模成正比。
* 对数空间复杂度 ( O(\log n) )：算法所需的额外空间以对数方式增长。
* 多项式空间复杂度 ( O(n^k) )：算法所需的额外空间与输入规模的多项式次方成正比。

## 扫码登录的实现方式
扫码登录是一种通过手机扫描二维码的方式进行身份验证的登录方式。它通常用于一些需要快速登录的系统，如微信、支付宝等。
### 扫码登录基本流程

1. 前端生成登录二维码
* 前端页面向服务器请求一个登录二维码的URL（这个URL通常指向后端的一个接口，该接口负责生成一个临时的登录令牌，并生成对应此令牌的二维码）。
* 前端使用这个URL生成二维码并显示给用户。

2. 用户扫码
* 用户使用手机扫描二维码，通常会被引导到一个登录授权页面。
* 用户在该页面进行授权操作（比如确认登录）。
  
3. 后端验证授权并回调前端
* 用户在手机上授权后，第三方平台会回调后端提供的回调URL，并附带授权信息（如access_token）。
* 后端验证授权信息，并关联到之前生成的临时登录令牌。
* 后端可以通过某种方式（如WebSocket、轮询、Server-Sent Events等）通知前端授权成功。

4. 前端处理登录成功
* 前端接收到登录成功的通知后，从服务器获取用户信息（如果需要），并跳转到相应的页面。

### vue3 + ts 示例代码
1. 前端显示二维码
使用 Vue 3 和 TypeScript，你可以使用 qrcode.vue 这样的 Vue 组件库来生成二维码。
```vue
<template>
  <div>
    <qrcode-vue :value="qrCodeUrl" :size="256"></qrcode-vue>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue';
import QrcodeVue from 'qrcode.vue';

export default defineComponent({
  components: {
    QrcodeVue
  },
  setup() {
    const qrCodeUrl = ref<string>('');

    // 模拟从服务器获取二维码URL
    // 在实际应用中，这里应该是一个API调用
    fetch('你的后端API/get-qrcode-url')
      .then(response => response.json())
      .then(data => {
        qrCodeUrl.value = data.url;
      });

    return { qrCodeUrl };
  }
});
</script>
```
2. 扫码后处理
扫码后的处理依赖于后端如何通知前端。如果使用 WebSocket，你可以在 Vue 组件中创建一个 WebSocket 连接，并监听来自服务器的消息。
```vue
<script lang="ts">
// ...

export default defineComponent({
  // ...
  setup() {
    const socket = new WebSocket('你的WebSocket服务器地址');

    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.type === 'login_success') {
        // 处理登录成功逻辑
      }
    };

    // 记得在组件卸载时关闭 WebSocket
    onUnmounted(() => {
      socket.close();
    });

    // ...
  }
});
</script>
```

## 前端水印
### 明水印
明水印是指通过在文本或图像上覆盖另一层图像或文字来实现的，明水印会明显的出现在页面上，通常用于显示版权信息或其它相关信息。

### 暗水印
暗水印是指将水印信息隐藏在图片的某些特性中，如颜色、亮度、频谱等，通过特定的算法提取出来。肉眼无法直接看到水印，但可以通过特定的软件或算法提取出来，通常用于版权追踪、内容验证等。
### 实现方式

### 实现方式
1. 明水印
* CSS实现：利用CSS的::before或::after伪元素，配合position: absolute;或position: relative;属性将水印文本或图片叠加在原始内容之上。
* Canvas实现：通过Canvas API在图片上绘制水印，并可以将处理后的图片作为新的图像源使用。
* SVG实现：利用SVG的矢量特性，在SVG图像中嵌入水印信息，并通过CSS或JavaScript控制其显示。
* 第三方库，如 WaterMark 等。
2. 暗水印
* 使用图像处理算法，如傅里叶变换，将水印信息嵌入到图像的频域中。
* 使用隐写术，将水印信息隐藏在图像的某些特性中，如颜色、亮度、频谱等。
* 使用机器学习算法，如卷积神经网络，将水印信息嵌入到图像中，并通过训练模型提取出来。

## 登录鉴权的过程
### 用户认证
前端操作：
- 用户输入用户名和密码，并提交登录表单。
- 表单数据通过HTTP请求（如POST请求）发送到后端服务器。

后端操作：
- 接收前端发送的用户名和密码。
- 在数据库中查询用户名，并验证密码是否正确（通常密码会以加密形式存储，如使用哈希算法）。
- 如果用户名和密码验证成功，则认为用户身份合法。
  
### 授权
后端操作：
- 根据用户的身份（如用户角色、权限等级等），确定用户可以访问的资源范围。
- 为用户生成一个表示其身份和权限的凭证（如Token、Session ID等）。
- 将凭证返回给前端。
### 鉴权
前端操作：
- 在发送请求时，将后端返回的凭证（如Token）附加到请求头中。
  
后端操作：
- 接收前端发送的请求，并解析请求头中的凭证。
- 验证凭证的有效性（如检查Token是否过期、是否被篡改等）。
- 如果凭证有效，则根据凭证中的信息判断用户是否有权访问请求的资源。
### 权限控制
后端操作：
- 根据鉴权结果，判断用户是否有权执行请求中的操作。
- 如果用户有权执行该操作，则处理请求并返回结果。
- 如果用户无权执行该操作，则返回相应的错误提示或拒绝访问的响应。

// TODO:
## 页面加载速度提升（性能优化）有哪些手段？

## 前端跨页面通信的方式
1. URL参数传递
  通过 URL 参数传递数据，在页面之间传递数据，并通过解析URL参数获取数据。
* 缺点：URL参数传递的数据只能是字符串，如果需要传递复杂的数据结构，需要将其序列化为字符串后再传递。
2. 浏览器缓存
  通过浏览器的本地存储（localStorage、sessionStorage 来传递数据），在不同页面可以通过读写这些存储对象来共享数据。
* 缺点：浏览器缓存的数据是持久化的，在浏览器关闭后，数据会被清除。不能实时通信，需要页面刷新或手动触发读取操作。
3. PostMessage
  window.postMessage() 方法允许从一个窗口向另一个窗口发送消息，不管它们是否来自同一源。
4. WebSocket
  WebSocket是一种用于创建持久连接的协议，允许浏览器和服务器进行全双工通信，可以实时通信，无需手动刷新页面。

## 前端项目权限设计
前端应⽤的权限设计应该考虑⻆⾊与权限分离、功能级与路由级的权限控制、动态权限管理、UI级的权限控制、异常处理与安全验证以及安全性考虑等⽅⾯。通过合理的权限设计，可以确保系统的安全性和⽤⼾权限的灵活管理。
### ⻆⾊与权限分离
将⽤⼾的权限分为不同的⻆⾊，每个⻆⾊拥有特定的权限。这样可以简化权限管理，并且当需求变化时，只需要调整⻆⾊的权限，⽽不需要逐个修改⽤⼾的权限。

在⻆⾊与权限分离的设计中，可以按照以下⼏个步骤进⾏
1. 确定权限集合：⾸先，需要确定系统中所有的权限，包括操作、功能、资源等。可以根据系统需求、业务流程等确定权限的粒度和层次结构。
2. 确定⻆⾊集合：根据系统的⻆⾊需求，确定不同的⻆⾊，例如管理员、普通⽤⼾、编辑等。每个⻆
⾊代表⼀组权限的集合，可以根据业务需求进⾏划分。
3. 分配权限给⻆⾊：将权限与⻆⾊进⾏关联，确定每个⻆⾊具备哪些权限。可以通过⻆⾊-权限的映射 表或者通过⻆⾊组的⽅式进⾏管理。
4. ⽤⼾与⻆⾊关联：将⽤⼾与⻆⾊进⾏关联，确定每个⽤⼾属于哪些⻆⾊。可以通过⽤⼾-⻆⾊的映射 表或者通过⽤⼾组的⽅式进⾏管理。
5. 权限验证：在系统中，根据⽤⼾的⻆⾊和权限配置进⾏权限验证。在⽤⼾进⾏操作或访问受限资源时，根据⽤⼾的⻆⾊与权限进⾏验证，决定是否允许执⾏相应的操作。

### 功能级权限控制
对于敏感操作或者需要权限控制的功能，需要在前端实现功能级的权限控制。
通过在代码中判断⽤⼾是否拥有执⾏该功能的权限，来决定是否展⽰或者禁⽤相关功能。
功能级权限控制是指在系统中对⽤⼾进⾏细粒度的权限控制，即控制⽤⼾是否能够执⾏某个具体的功能或操作。

以下是功能级权限控制的设计步骤：
1. 确定功能点：⾸先，需要明确系统中的各个功能点，例如新增、编辑、删除、查询等。将系统中的所有功能进⾏明确定义和分类。
2. 定义权限：对于每个功能点，定义相应的权限。权限可以使⽤权限名或者权限码进⾏标识，例如新增权限可以使⽤"add"或者权限码"001"进⾏标识。
3. ⻆⾊与权限关联：将权限与⻆⾊进⾏关联。确定每个⻆⾊具备哪些权限。可以使⽤⻆⾊-权限的映射 表进⾏管理。
4. ⽤⼾与⻆⾊关联：将⽤⼾与⻆⾊进⾏关联。确定每个⽤⼾属于哪些⻆⾊。可以使⽤⽤⼾-⻆⾊的映射 表进⾏管理。
5. 权限验证：在系统中，对⽤⼾进⾏权限验证。当⽤⼾进⾏某个功能操作时，根据⽤⼾的⻆⾊与权限进⾏验证，决定是否允许执⾏该操作。
6. 权限控制界⾯：提供⼀个权限控制界⾯，⽤于管理⻆⾊与权限的关联。管理员可以通过该界⾯对⻆
⾊的权限进⾏配置和管理。
7. 动态权限控制：可以考虑将权限控制设计成动态的。即在系统运⾏时，可以根据⽤⼾⻆⾊的配置动态控制⽤⼾是否具备某个功能的权限。 这样可以灵活地根据业务需求进⾏权限的调整。

### 路由级权限控制
对于不同的⻚⾯或路由，可以根据⽤⼾的⻆⾊或权限来进⾏权限控制。在前端路由中配置权限信息， 当⽤⼾访问特定路由时，前端会检查⽤⼾是否具备访问该路由的权限。
前端路由级权限控制是指在前端⻚⾯中根据⽤⼾的权限配置，控制⽤⼾是否可以访问某个路由或者⻚⾯。

以下是前端路由级权限控制的设计⽅案：
1. 定义路由表：⾸先，需要定义系统中的所有路由和对应的⻚⾯组件。将路由按照功能模块进⾏分类，⽅便后续的权限管理。
2. 定义权限配置：对于每个路由或者⻚⾯，定义相应的权限配置。可以使⽤权限名或者权限码进⾏标识，例如"add"、"edit"等。可以将权限配置与路由表⼀起存放在⼀个配置⽂件中，或者存放在后端数据库中。
3. 获取⽤⼾权限：在登录成功后，从后端获取当前⽤⼾的权限信息。可以将⽤⼾的权限信息存放在前端的状态管理库（如Vuex或Redux）中，以便在全局范围内进⾏访问。
4. 路由守卫：使⽤前端路由守卫机制，在路由跳转前进⾏权限验证。在路由守卫中，根据当前⽤⼾的权限信息和路由配置进⾏判断，决定是否允许⽤⼾访问该路由。如果⽤⼾没有相应的权限，可以进
⾏跳转到⽆权限提⽰⻚⾯或者其他处理⽅式。
5. 权限控制组件：可以创建⼀个权限控制组件，在需要进⾏权限控制的路由组件上使⽤该组件进⾏包裹。该组件可以根据当前⽤⼾的权限和路由配置，动态显⽰或隐藏路由组件。
6. 动态路由：对于⼀些有权限控制的路由，可以在⽤⼾登录时根据权限配置动态⽣成。根据⽤⼾的权限配置，过滤路由表，⽣成⽤⼾可以访问的路由列表，并将该列表添加到路由配置中。

### 动态权限管理
在前端应⽤中，可以实现动态权限管理，即在⽤⼾登录时从服务器获取⽤⼾的权限信息，并在前端进
⾏缓存。这样可以保证⽤⼾权限的实时性，同时也便于后端对权限进⾏调整和管理。

### UI级的权限控制
对于某些敏感信息或操作，可以通过前端的界⾯设计来进⾏权限控制。例如，隐藏某些敏感字段或操作按钮，只对具有相应权限的⽤⼾可⻅或可操作。

### 异常处理与安全验证
在前端应⽤中，需要实现异常处理机制，当⽤⼾越权操作时，需要给予相应提⽰并记录⽇志。同时， 对于敏感操作，需要进⾏⼆次验证，例如通过输⼊密码或短信验证码等⽅式进⾏安全验证。

### 安全性考虑
在设计前端应⽤的权限时，需要考虑安全性，例如防⽌跨站脚本攻击（XSS）、跨站请求伪造
（CSRF）等攻击⽅式。可以采⽤合适的安全措施，如输⼊验证、加密传输等来保护应⽤的安全性。

综上所述，前端应⽤的权限设计应该考虑⻆⾊与权限分离、功能级与路由级的权限控制、动态权限管理、UI级的权限控制、异常处理与安全验证以及安全性考虑等⽅⾯。通过合理的权限设计，可以确保 系统的安全性和⽤⼾权限的灵活管理。
